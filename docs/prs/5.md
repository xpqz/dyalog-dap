# PR Description - Issue #5

Issue: #5 - Implement single-reader dispatcher and prompt-aware outbound scheduler  
Branch: codex/5-implement-single-reader-dispatcher-and-prompt-aware-outbound-scheduler  
Plan reference: /Users/stefan/work/lsp-dap/docs/plans/ride-protocol.md (sections 3 and 6)

## Summary

This change introduces a session dispatcher that owns the single-reader RIDE receive loop, publishes decoded inbound protocol events via a non-blocking subscriber bus, and enforces prompt-aware outbound command scheduling.

Core behavior added:

- single inbound read/decode loop over transport payloads
- prompt type tracking from `SetPromptType`
- outbound send gating while `promptType=0` (busy)
- allow-list bypass for interrupt/reply/save-close style commands during busy state
- queued command flush when prompt transitions from busy to ready (`type != 0`)

## Why this change

Per the plan, RIDE messaging is asynchronous and prompt state is a correctness boundary. The adapter cannot assume request/reply ordering and must not block receive processing while handling outbound control flow. This PR establishes that runtime contract in `sessionstate` before DAP request mapping is layered on top.

## Scope of changes

Files changed:

- /Users/stefan/work/lsp-dap/internal/ride/sessionstate/dispatcher.go
- /Users/stefan/work/lsp-dap/internal/ride/sessionstate/dispatcher_test.go

Implemented in `dispatcher.go`:

- `Transport` interface (`ReadPayload`, `WritePayload`) for runtime decoupling from concrete socket client
- `Dispatcher` with:
  - `Run(context.Context)` single-reader loop
  - `Subscribe(buffer)` non-blocking event bus with unsubscribe callback
  - `PromptType()` state inspection (`type`, `seen`)
  - `SendCommand(command, args)` with busy-state queueing policy
- prompt transition handling:
  - consumes inbound `SetPromptType`
  - records readiness state
  - flushes queued commands when transitioning from busy (`0`) to ready (`!=0`)
- busy allow-list policy:
  - explicit allow-list (`WeakInterrupt`, `StrongInterrupt`, `SaveChanges`, `ReplySaveChanges`, `CloseWindow`)
  - generic reply bypass via `strings.HasPrefix(command, "Reply")`
- tolerant queue flush behavior:
  - preserves queue order
  - requeues command at head if a flush write fails

## Test coverage

Added `/Users/stefan/work/lsp-dap/internal/ride/sessionstate/dispatcher_test.go` with:

- `TestDispatcher_PublishesIncomingEvents`
  - verifies inbound decode + event publish pipeline
- `TestDispatcher_QueuesBusyCommandsAndFlushesWhenReady`
  - verifies queueing of non-allow-listed commands during busy prompt
  - verifies immediate send for allow-listed command during busy prompt
  - verifies queued command flush on prompt transition to ready
- `TestDispatcher_DoesNotBlockOnSlowSubscriber`
  - verifies non-blocking publish semantics (slow/full subscriber does not stall prompt-state progression)

Tests use a mock transport to deterministically drive inbound payloads and observe outbound writes.

## Validation performed

Commands run:

- `go test ./...`
- `go vet ./...`

Result:

- all tests pass
- vet clean

## Compatibility and risk

Behavioral intent:

- preserve transport tolerance by avoiding strict coupling between inbound event handling and subscriber consumption
- avoid runtime deadlock by ensuring subscriber channels are written with non-blocking sends

Known limitations in this PR:

- dispatcher currently does not expose an error stream for non-EOF read/decode failures
- busy allow-list is static and local to dispatcher
- cancellation responsiveness depends on transport read behavior (blocking reads still require transport shutdown)

## Out of scope

Not included here:

- DAP request/event routing integration
- thread/frame model integration with session-state consumers
- live Dyalog integration tests (addressed by later testing epics)

## Reviewer guide

Recommended review order:

1. `/Users/stefan/work/lsp-dap/internal/ride/sessionstate/dispatcher_test.go` for contract expectations.
2. `/Users/stefan/work/lsp-dap/internal/ride/sessionstate/dispatcher.go` for queueing/state-machine behavior.
3. confirm allow-list policy is appropriate for current phase and whether it should become configurable in a follow-up.

## Follow-up expected

Likely immediate follow-ups:

- wire dispatcher events into the upcoming DAP adapter lifecycle handlers
- add protocol-traffic diagnostics (`#6`) to aid integration triage

## Review follow-up

Addressed `crev` findings with two fixes:

- queue flush durability: on write failure during busy->ready flush, dispatcher now requeues the failed command plus all remaining queued commands in order (no command loss)
- publish/unsubscribe safety: dispatcher no longer closes subscriber channels on unsubscribe and publish now tolerates closed-channel sends defensively, removing invalid subscribers without panicking

Additional tests added:

- `TestDispatcher_FlushFailureRequeuesRemainingCommandsInOrder`
- `TestDispatcher_PublishDoesNotPanicWhenSubscriberChannelIsClosed`
